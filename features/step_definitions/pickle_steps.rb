# this file generated by script/generate pickle

# create a model
Given(/^#{capture_model} exists?(?: with #{capture_fields})?$/) do |name, fields|
  mdl = create_model(name, fields)
  if name[0,6] == "a user"
  	#/role:\s"(.+?)"/ =~ ( fields )
		roles = mdl[-1].role
		roles_code = {}
		roles_code["god"] = 1
		roles_code["admin"] = 2
		roles_code["observer"] = 4
		roles_code["teatcher"] = 8
		roles_code["student"] = 16
		roles_code["registrant"] = 32
		roles_code["photographer"] = 64
		
		roles_mask = 0
		roles.split(', ').each do |role|
			roles_mask += roles_code[role]
		end
	  mdl[-1].update_attribute( :roles_mask, roles_mask )
#	  p mdl
#  	p mdl[-1].roles_mask
#  	#model.update_attribute( :role, $1 )
#  end
	end
end

# create n models
Given(/^(\d+) #{capture_plural_factory} exist(?: with #{capture_fields})?$/) do |count, plural_factory, fields|
  count.to_i.times { create_model(plural_factory.singularize, fields) }
end

# create models from a table
Given /^the following #{capture_plural_factory} exist$/ do |plural_factory, table|
  name = plural_factory.singularize
  table.hashes.each { |hash| create_model(name, hash) }
end

# find a model
Then(/^#{capture_model} should exist(?: with #{capture_fields})?$/) do |name, fields|
  find_model(name, fields).should_not be_nil
end

# not find a model
Then(/^#{capture_model} should not exist(?: with #{capture_fields})?$/) do |name, fields|
  find_model(name, fields).should be_nil
end

# find exactly n models
Then(/^(\d+) #{capture_plural_factory} should exist(?: with #{capture_fields})?$/) do |count, plural_factory, fields|
  find_models(plural_factory.singularize, fields).size.should == count.to_i
end

# assert model is in another model's has_many assoc
Then(/^#{capture_model} should be (?:in|one of|amongst) #{capture_model}'s (\w+)$/) do |target, owner, association|
  model(owner).send(association).should include(model(target))
end

# assert model is not in another model's has_many assoc
Then(/^#{capture_model} should not be (?:in|one of|amongst) #{capture_model}'s (\w+)$/) do |target, owner, association|
  model(owner).send(association).should_not include(model(target))
end

# assert model is another model's has_one/belongs_to assoc
Then(/^#{capture_model} should be #{capture_model}'s (\w+)$/) do |target, owner, association|
  model(owner).send(association).should == model(target)
end

# assert model is not another model's has_one/belongs_to assoc
Then(/^#{capture_model} should not be #{capture_model}'s (\w+)$/) do |target, owner, association|
  model(owner).send(association).should_not == model(target)
end

# assert model.predicate? 
Then(/^#{capture_model} should (?:be|have) (?:an? )?#{capture_predicate}$/) do |name, predicate|
  model(name).should send("be_#{predicate.gsub(' ', '_')}")
end

# assert not model.predicate?
Then(/^#{capture_model} should not (?:be|have) (?:an? )?#{capture_predicate}$/) do |name, predicate|
  model(name).should_not send("be_#{predicate.gsub(' ', '_')}")
end